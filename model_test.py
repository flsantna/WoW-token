import numpy as np
from config import list_key, total_epochs, look_back, window, configs_test, threshold_eval
from bin.model import LSTM_Model
from data_proc import Processing, plot_graph, window_to_series
import tensorflow as tf
from config import test_type


def map_classification(data, predict):
    if predict >= data:
        predict = 1
        return predict
    else:
        predict = 0
        return predict


def map_comparison(item_x, item_y):
    if item_x == item_y:
        return True
    else:
        return False


if __name__ == '__main__':
    test_rate = 0.15
    data_test_x, data_test_y = [], []
    # Test type 0 is a test that only shows one graph and the testing is done using the last true data as look back.
    if test_type == 0:
        # Creating class that process all the data from the CSV in "dataset/"
        proc = Processing()
        # Model creation, as parameters is needed window and look_back value.
        model = LSTM_Model(window=window, look_back=look_back)
        model_load_path = 'model/w{}/lb{}_trained_with_{}_total_val_loss_mean.result()epochs{}'\
            .format(window, look_back, list_key[4], total_epochs)
        for key in range(len(list_key)):

            data_x, data_y = proc.get_data(key=key, look_back=look_back, window=window)
            test_size = int(data_x.shape[0] * test_rate)

            data_test_x = data_x[-test_size:]
            data_train_y = data_y[:-test_size]
            data_test_y = data_y[-test_size:]
            # Dates str for plot.
            dates = proc.dates_list

            model.load_weights(filepath=model_load_path)
            prediction = model.call(data_test_x)

            predicted_map = list(map(map_classification, tf.squeeze(data_test_x, axis=-1).numpy()[..., -1:].tolist()
                                     , prediction.numpy().tolist()))
            label_map = list(map(map_classification, tf.squeeze(data_test_x, axis=-1).numpy()[..., -1:].tolist()
                                 , data_test_y.numpy().tolist()))

            accuracy = list(map(map_comparison, label_map, predicted_map))
            rmse = tf.math.sqrt(
                tf.keras.losses.mean_squared_error(y_true= tf.squeeze(data_test_x, axis=-1)[..., -1:], y_pred=prediction))

            print("Accuracy: ", sum(accuracy), "/", len(accuracy))
            print("RMSE: {}".format(np.mean(rmse.numpy())))



# Test type 1, feed itself with generated data as it's predicting forward. It is generated two graphs, one with full
# data that is generated by the model and other showing all intervals that where chosen in "predicted_days" comparing
# and calculating it's RMSE (Reduced Mean Squared Error).

    elif test_type == 1:
        for key in range(len(list_key)):
            # Defining classes to data and model generation.
            proc = Processing()
            model = LSTM_Model(window=window, look_back=look_back)
            # Definition of which weights to load, if desired.
            model_load_path = 'model/w{}/lb{}_trained_with_{}_total_epochs{}' \
                .format(window, look_back, list_key[4], total_epochs)
            model.load_weights(filepath=model_load_path)

            data_x, data_y = proc.get_data(key=key, window=window, look_back=look_back)
            dates = proc.dates_list
            # Dataset preparation.
            test_size = int(data_x.shape[0] * test_rate)
            data_test_x = data_x[-test_size:]
            data_test_y = data_y[-test_size:]
            data_train_y = data_y[:-test_size]
            # Dates list to plot.
            dates_train = dates[:-test_size]
            dates_test = dates[-test_size:]
            dates_to_plot_all = dates_test[:configs_test[3][0]]

            # Testing the complete test dataset generation by the model.
            data_pred_test = data_test_x[0]
            predict_list = []
            for _ in range(data_test_x.shape[0]):
                predict_value = model.call(inputs=tf.expand_dims(data_pred_test, axis=0))
                predict_list.append(tf.squeeze(predict_value, axis=0))
                predict_value = tf.reshape(predict_value, shape=[window, 1])
                data_transfer = data_pred_test[..., 1:]
                data_transfer = np.concatenate([data_transfer, predict_value], axis=1)
                data_pred_test = data_transfer
            predict = tf.cast(predict_list, dtype=tf.dtypes.float32)

            data_in_series_y = proc.real_dataset(key)[-test_size:]
            data_pred_series_y = window_to_series(predict, window=window)[:test_size]
            data_train_series_y = proc.real_dataset(key)[:-test_size]

            pred_y_unit = tf.squeeze(model.call(inputs=tf.expand_dims(data_test_x[0], axis=0)), axis=0)
            test_y_unit = data_test_y[0]
            test_x_unit = data_in_series_y[:look_back]

            rmse = tf.math.sqrt(
                tf.keras.losses.mean_squared_error(y_true=data_in_series_y, y_pred=data_pred_series_y))
            rmse_2 = tf.math.sqrt(tf.keras.losses.mean_squared_error(y_true=test_y_unit, y_pred=pred_y_unit))
            print('{} RMSE: {}'.format(list_key[key], rmse))

            plot_graph(true_data=np.append(data_train_series_y, data_in_series_y, axis=0),
                       dates=dates,
                       window=window,
                       test_size=test_size,
                       predicted_data=[np.append(data_train_series_y, data_pred_series_y, axis=0),
                                       '{} : RMSE: {:.5f}'.format(list_key[key], rmse.numpy())],
                       title=list_key[key],
                       file_name="all data",
                       plot_predict=True,
                       plot=True)

            plot_graph(true_data=np.append(test_x_unit, test_y_unit, axis=0),
                       window=window,
                       test_size=window,
                       dates=dates_test[:(window+look_back)],
                       predicted_data=[np.append(test_x_unit, pred_y_unit, axis=0),
                                       '{} : RMSE: {:.5f}'.format(list_key[key], rmse_2.numpy())],
                       title=list_key[key],
                       plot_predict=True,
                       plot=True)
